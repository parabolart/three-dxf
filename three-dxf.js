!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],n):"object"==typeof exports?exports.ThreeDxf=n(require("THREE")):t.ThreeDxf=n(t.THREE)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(t){var n={};function c(e){if(n[e])return n[e].exports;var l=n[e]={i:e,l:!1,exports:{}};return t[e].call(l.exports,l,l.exports,c),l.l=!0,l.exports}return c.m=t,c.c=n,c.d=function(t,n,e){c.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},c.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},c.t=function(t,n){if(1&n&&(t=c(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(c.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var l in t)c.d(e,l,function(n){return t[n]}.bind(null,l));return e},c.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return c.d(n,"a",n),n},c.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},c.p="",c(c.s=1)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi9leHRlcm5hbCBcIlRIUkVFXCI/ZmMwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external \"THREE\"\nvar external_THREE_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/OrbitControls.js\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\n\r\n\r\nfunction OrbitControls( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the control orbits around\r\n\t// and where it pans with respect to.\r\n\tthis.target = new external_THREE_[\"Vector3\"]();\r\n\r\n\t// center is old, deprecated; use \"target\" instead\r\n\tthis.center = this.target;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for\r\n\t// backwards compatibility\r\n\tthis.noZoom = false;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Limits to how far you can dolly in and out\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noRotate = false;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noPan = false;\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// Set to true to disable use of the keys\r\n\tthis.noKeys = false;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t////////////\r\n\t// internals\r\n\r\n\tvar scope = this;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar rotateStart = new external_THREE_[\"Vector2\"]();\r\n\tvar rotateEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar rotateDelta = new external_THREE_[\"Vector2\"]();\r\n\r\n\tvar panStart = new external_THREE_[\"Vector2\"]();\r\n\tvar panEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar panDelta = new external_THREE_[\"Vector2\"]();\r\n\tvar panOffset = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar offset = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar dollyStart = new external_THREE_[\"Vector2\"]();\r\n\tvar dollyEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar dollyDelta = new external_THREE_[\"Vector2\"]();\r\n\r\n\tvar phiDelta = 0;\r\n\tvar thetaDelta = 0;\r\n\tvar scale = 1;\r\n\tvar pan = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar lastPosition = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\t// for reset\r\n\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start'};\r\n\tvar endEvent = { type: 'end'};\r\n\r\n\tthis.rotateLeft = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tthetaDelta -= angle;\r\n\r\n\t};\r\n\r\n\tthis.rotateUp = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tphiDelta -= angle;\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move left\r\n\tthis.panLeft = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get X column of matrix\r\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\tpanOffset.multiplyScalar( - distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move up\r\n\tthis.panUp = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get Y column of matrix\r\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\tpanOffset.multiplyScalar( distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\t\r\n\t// pass in x,y of change desired in pixel space,\r\n\t// right and down are positive\r\n\tthis.pan = function ( deltaX, deltaY ) {\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( scope.object.fov !== undefined ) {\r\n\r\n\t\t\t// perspective\r\n\t\t\tvar position = scope.object.position;\r\n\t\t\tvar offset = position.clone().sub( scope.target );\r\n\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t// half of the fov is center to top of screen\r\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\r\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\r\n\r\n\t\t} else if ( scope.object.top !== undefined ) {\r\n            \r\n\t\t\t// orthographic\r\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\r\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// camera neither orthographic or perspective\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dollyIn = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale /= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.dollyOut = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale *= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n        \r\n        if(scope.object.top !== undefined) {\r\n            this.object.top = (scale*this.object.top);\r\n            this.object.bottom = (scale*this.object.bottom);\r\n            this.object.left = (scale*this.object.left);\r\n            this.object.right = (scale*this.object.right);\r\n            \r\n            this.object.updateProjectionMatrix();\r\n\r\n        }\r\n            \r\n\r\n\t\tvar position = this.object.position;\r\n\r\n\t\toffset.copy( position ).sub( this.target );\r\n//\r\n//\t\t// angle from z-axis around y-axis\r\n//\r\n//\t\tvar theta = Math.atan2( offset.x, offset.z );\r\n//\r\n//\t\t// angle from y-axis\r\n//\r\n//\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n//\r\n//\t\tif ( this.autoRotate ) {\r\n//\r\n//\t\t\tthis.rotateLeft( getAutoRotationAngle() );\r\n//\r\n//\t\t}\r\n//\r\n//\t\ttheta += thetaDelta;\r\n//\t\tphi += phiDelta;\r\n//\r\n//\t\t// restrict phi to be between desired limits\r\n//\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n//\r\n//\t\t// restrict phi to be betwee EPS and PI-EPS\r\n//\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n//\r\n//\t\tvar radius = offset.length() * scale;\r\n//\r\n//\t\t// restrict radius to be between desired limits\r\n//\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n//\t\t\r\n//\t\t// move target to panned location\r\n\t\tthis.target.add( pan );\r\n//\t\t\r\n//\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n//\t\toffset.y = radius * Math.cos( phi );\r\n//\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n//\r\n\t\tposition.copy( this.target ).add( offset );\r\n\r\n\t\tthis.object.lookAt( this.target );\r\n\r\n\r\n//\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 || scale !== 1 ) {\r\n\r\n\t\t\tthis.dispatchEvent( changeEvent );\r\n\r\n//\t\t\tlastPosition.copy( this.object.position );\r\n\r\n//\t\t}\r\n        \r\n//        thetaDelta = 0;\r\n//\t\tphiDelta = 0;\r\n\t\tscale = 1;\r\n\t\tpan.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t\tthis.target.copy( this.target0 );\r\n\t\tthis.object.position.copy( this.position0 );\r\n\r\n\t\tthis.update();\r\n\r\n\t};\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( event.button === 0 ) {\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 1 ) {\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 2 ) {\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t\tscope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t} else if ( state === STATE.DOLLY ) {\r\n\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tpanEnd.set( event.clientX, event.clientY );\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\r\n\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta;\r\n\r\n\t\t} else if ( event.detail !== undefined ) { // Firefox\r\n\r\n\t\t\tdelta = - event.detail;\r\n\r\n\t\t}\r\n\r\n\t\tif ( delta > 0 ) {\r\n\r\n\t\t\tscope.dollyOut();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.dollyIn();\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\t\tscope.dispatchEvent( startEvent );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\r\n\t\t\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\t\t\tdollyStart.set( 0, distance );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\r\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\r\n\r\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tdollyEnd.set( 0, distance );\r\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\r\n\r\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\t\r\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchend( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\r\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\r\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( external_THREE_[\"EventDispatcher\"].prototype );\n// CONCATENATED MODULE: ./src/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewer\", function() { return Viewer; });\n\r\n\r\n\r\n// Three.js extension functions. Webpack doesn't seem to like it if we modify the THREE object directly.\r\nvar THREEx = { Math: {} };\r\n/**\r\n * Returns the angle in radians of the vector (p1,p2). In other words, imagine\r\n * putting the base of the vector at coordinates (0,0) and finding the angle\r\n * from vector (1,0) to (p1,p2).\r\n * @param  {Object} p1 start point of the vector\r\n * @param  {Object} p2 end point of the vector\r\n * @return {Number} the angle\r\n */\r\nTHREEx.Math.angle2 = function(p1, p2) {\r\n\tvar v1 = new external_THREE_[\"Vector2\"](p1.x, p1.y);\r\n\tvar v2 = new external_THREE_[\"Vector2\"](p2.x, p2.y);\r\n\tv2.sub(v1); // sets v2 to be our chord\r\n\tv2.normalize();\r\n\tif(v2.y < 0) return -Math.acos(v2.x);\r\n\treturn Math.acos(v2.x);\r\n};\r\n\r\n\r\nTHREEx.Math.polar = function(point, distance, angle) {\r\n\tvar result = {};\r\n\tresult.x = point.x + distance * Math.cos(angle);\r\n\tresult.y = point.y + distance * Math.sin(angle);\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Calculates points for a curve between two points\r\n * @param startPoint - the starting point of the curve\r\n * @param endPoint - the ending point of the curve\r\n * @param bulge - a value indicating how much to curve\r\n * @param segments - number of segments between the two given points\r\n */\r\nTHREEx.BulgeGeometry = function ( startPoint, endPoint, bulge, segments ) {\r\n\r\n\tvar vertex, i,\r\n\t\tcenter, p0, p1, angle,\r\n\t\tradius, startAngle,\r\n\t\tthetaAngle;\r\n\r\n\texternal_THREE_[\"Geometry\"].call( this );\r\n\r\n\tthis.startPoint = p0 = startPoint ? new external_THREE_[\"Vector2\"](startPoint.x, startPoint.y) : new external_THREE_[\"Vector2\"](0,0);\r\n\tthis.endPoint = p1 = endPoint ? new external_THREE_[\"Vector2\"](endPoint.x, endPoint.y) : new external_THREE_[\"Vector2\"](1,0);\r\n\tthis.bulge = bulge = bulge || 1;\r\n\r\n\tangle = 4 * Math.atan(bulge);\r\n\tradius = p0.distanceTo(p1) / 2 / Math.sin(angle/2);\r\n\tcenter = THREEx.Math.polar(startPoint, radius, THREEx.Math.angle2(p0,p1) + (Math.PI / 2 - angle/2));\r\n\r\n\tthis.segments = segments = segments || Math.max( Math.abs(Math.ceil(angle/(Math.PI/18))), 6); // By default want a segment roughly every 10 degrees\r\n\tstartAngle = THREEx.Math.angle2(center, p0);\r\n\tthetaAngle = angle / segments;\r\n\r\n\r\n\tthis.vertices.push(new external_THREE_[\"Vector3\"](p0.x, p0.y, 0));\r\n\r\n\tfor(i = 1; i <= segments - 1; i++) {\r\n\r\n\t\tvertex = THREEx.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);\r\n\r\n\t\tthis.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREEx.BulgeGeometry.prototype = Object.create( external_THREE_[\"Geometry\"].prototype );\r\n    \r\n/**\r\n * Viewer class for a dxf object.\r\n * @param {Object} data - the dxf object\r\n * @param {Object} parent - the parent element to which we attach the rendering canvas\r\n * @param {Number} width - width of the rendering canvas in pixels\r\n * @param {Number} height - height of the rendering canvas in pixels\r\n * @param {Object} font - a font loaded with THREE.FontLoader \r\n * @constructor\r\n */\r\nfunction Viewer(data, parent, width, height, font) {\r\n\r\n    createLineTypeShaders(data);\r\n\r\n    var scene = new external_THREE_[\"Scene\"]();\r\n\r\n    // Create scene from dxf object (data)\r\n    var i, entity, obj, min_x, min_y, min_z, max_x, max_y, max_z;\r\n    var dims = {\r\n        min: { x: false, y: false, z: false},\r\n        max: { x: false, y: false, z: false}\r\n    };\r\n    for(i = 0; i < data.entities.length; i++) {\r\n        entity = data.entities[i];\r\n\r\n        if(entity.type === 'DIMENSION') {\r\n            if(entity.block) {\r\n                var block = data.blocks[entity.block];\r\n                if(!block) {\r\n                    console.error('Missing referenced block \"' + entity.block + '\"');\r\n                    continue;\r\n                }\r\n                for(var j = 0; j < block.entities.length; j++) {\r\n                    obj = drawEntity(block.entities[j], data);\r\n                }\r\n            } else {\r\n                console.log('WARNING: No block for DIMENSION entity');\r\n            }\r\n        } else {\r\n            obj = drawEntity(entity, data);\r\n        }\r\n\r\n        if (obj) {\r\n            var bbox = new external_THREE_[\"Box3\"]().setFromObject(obj);\r\n            if (bbox.min.x && ((dims.min.x === false) || (dims.min.x > bbox.min.x))) dims.min.x = bbox.min.x;\r\n            if (bbox.min.y && ((dims.min.y === false) || (dims.min.y > bbox.min.y))) dims.min.y = bbox.min.y;\r\n            if (bbox.min.z && ((dims.min.z === false) || (dims.min.z > bbox.min.z))) dims.min.z = bbox.min.z;\r\n            if (bbox.max.x && ((dims.max.x === false) || (dims.max.x < bbox.max.x))) dims.max.x = bbox.max.x;\r\n            if (bbox.max.y && ((dims.max.y === false) || (dims.max.y < bbox.max.y))) dims.max.y = bbox.max.y;\r\n            if (bbox.max.z && ((dims.max.z === false) || (dims.max.z < bbox.max.z))) dims.max.z = bbox.max.z;\r\n            scene.add(obj);\r\n        }\r\n        obj = null;\r\n    }\r\n\r\n    width = width || parent.innerWidth;\r\n    height = height || parent.innerHeight;\r\n    var aspectRatio = width / height;\r\n\r\n    var upperRightCorner = { x: dims.max.x, y: dims.max.y };\r\n    var lowerLeftCorner = { x: dims.min.x, y: dims.min.y };\r\n\r\n    // Figure out the current viewport extents\r\n    var vp_width = upperRightCorner.x - lowerLeftCorner.x;\r\n    var vp_height = upperRightCorner.y - lowerLeftCorner.y;\r\n    var center = center || {\r\n        x: vp_width / 2 + lowerLeftCorner.x,\r\n        y: vp_height / 2 + lowerLeftCorner.y\r\n    };\r\n\r\n    // Fit all objects into current ThreeDXF viewer\r\n    var extentsAspectRatio = Math.abs(vp_width / vp_height);\r\n    if (aspectRatio > extentsAspectRatio) {\r\n        vp_width = vp_height * aspectRatio;\r\n    } else {\r\n        vp_height = vp_width / aspectRatio;\r\n    }\r\n    \r\n    var viewPort = {\r\n        bottom: -vp_height / 2,\r\n        left: -vp_width / 2,\r\n        top: vp_height / 2,\r\n        right: vp_width / 2,\r\n        center: {\r\n            x: center.x,\r\n            y: center.y\r\n        }\r\n    };\r\n\r\n    var camera = new external_THREE_[\"OrthographicCamera\"](viewPort.left, viewPort.right, viewPort.top, viewPort.bottom, 1, 19);\r\n    camera.position.z = 10;\r\n    camera.position.x = viewPort.center.x;\r\n    camera.position.y = viewPort.center.y;\r\n\r\n    var renderer = this.renderer = new external_THREE_[\"WebGLRenderer\"]();\r\n    renderer.setSize(width, height);\r\n    renderer.setClearColor(0xfffffff, 1);\r\n\r\n    parent.appendChild(renderer.domElement);\r\n    parent.style.display = 'block';\r\n\r\n    //TODO: Need to make this an option somehow so others can roll their own controls.\r\n    var controls = new OrbitControls(camera, parent);\r\n    controls.target.x = camera.position.x;\r\n    controls.target.y = camera.position.y;\r\n    controls.target.z = 0;\r\n    controls.zoomSpeed = 3;\r\n\r\n    //Uncomment this to disable rotation (does not make much sense with 2D drawings).\r\n    //controls.enableRotate = false;\r\n\r\n    this.render = function() { renderer.render(scene, camera) };\r\n    controls.addEventListener('change', this.render);\r\n    this.render();\r\n    controls.update();\r\n\r\n    this.resize = function(width, height) {\r\n        var originalWidth = renderer.domElement.width;\r\n        var originalHeight = renderer.domElement.height;\r\n\r\n        var hscale = width / originalWidth;\r\n        var vscale = height / originalHeight;\r\n\r\n\r\n        camera.top = (vscale * camera.top);\r\n        camera.bottom = (vscale * camera.bottom);\r\n        camera.left = (hscale * camera.left);\r\n        camera.right = (hscale * camera.right);\r\n\r\n//        camera.updateProjectionMatrix();\r\n\r\n        renderer.setSize(width, height);\r\n        renderer.setClearColor(0xfffffff, 1);\r\n        this.render();\r\n    };\r\n\r\n    function drawEntity(entity, data) {\r\n        var mesh;\r\n        if(entity.type === 'CIRCLE' || entity.type === 'ARC') {\r\n            mesh = drawArc(entity, data);\r\n        } else if(entity.type === 'LWPOLYLINE' || entity.type === 'LINE' || entity.type === 'POLYLINE') {\r\n            mesh = drawLine(entity, data);\r\n        } else if(entity.type === 'TEXT') {\r\n            mesh = drawText(entity, data);\r\n        } else if(entity.type === 'SOLID') {\r\n            mesh = drawSolid(entity, data);\r\n        } else if(entity.type === 'POINT') {\r\n            mesh = drawPoint(entity, data);\r\n        } else if(entity.type === 'INSERT') {\r\n            mesh = drawBlock(entity, data);\r\n        } else if(entity.type === 'SPLINE') {\r\n            mesh = drawSpline(entity, data);\r\n        } else if(entity.type === 'MTEXT') {\r\n            mesh = drawMtext(entity, data);\r\n        } else if(entity.type === 'ELLIPSE') {\r\n            mesh = drawEllipse(entity, data);\r\n        }\r\n        else {\r\n            console.log(\"Unsupported Entity Type: \" + entity.type);\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    function drawEllipse(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x,2) + Math.pow(entity.majorAxisEndPoint.y,2));\r\n        var yrad = xrad*entity.axisRatio;\r\n        var rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);\r\n\r\n        var curve = new external_THREE_[\"EllipseCurve\"](\r\n            entity.center.x,  entity.center.y,\r\n            xrad, yrad,\r\n            entity.startAngle, entity.endAngle,\r\n            false, // Always counterclockwise\r\n            rotation\r\n        );\r\n\r\n        var points = curve.getPoints( 50 );\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]( {  linewidth: 1, color : color } );\r\n\r\n        // Create the final object to add to the scene\r\n        var ellipse = new external_THREE_[\"Line\"]( geometry, material );\r\n        return ellipse;\r\n    }\r\n\r\n    function drawMtext(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var geometry = new external_THREE_[\"TextGeometry\"]( entity.text, {\r\n            font: font,\r\n            size: entity.height * (4/5),\r\n            height: 1\r\n        });\r\n        var material = new external_THREE_[\"MeshBasicMaterial\"]( {color: color} );\r\n        var text = new external_THREE_[\"Mesh\"]( geometry, material );\r\n\r\n        // Measure what we rendered.\r\n        var measure = new external_THREE_[\"Box3\"]();\r\n        measure.setFromObject( text );\r\n\r\n        var textWidth  = measure.max.x - measure.min.x;\r\n\r\n        // If the text ends up being wider than the box, it's supposed\r\n        // to be multiline. Doing that in threeJS is overkill.\r\n        if (textWidth > entity.width) {\r\n            console.log(\"Can't render this multipline MTEXT entity, sorry.\", entity);\r\n            return undefined;\r\n        }\r\n\r\n        text.position.z = 0;\r\n        switch (entity.attachmentPoint) {\r\n            case 1:\r\n                // Top Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 2:\r\n                // Top Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 3:\r\n                // Top Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n\r\n            case 4:\r\n                // Middle Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 5:\r\n                // Middle Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 6:\r\n                // Middle Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n\r\n            case 7:\r\n                // Bottom Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 8:\r\n                // Bottom Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 9:\r\n                // Bottom Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n\r\n            default:\r\n                return undefined;\r\n        };\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawSpline(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var points = entity.controlPoints.map(function(vec) {\r\n            return new external_THREE_[\"Vector2\"](vec.x, vec.y);\r\n        });\r\n\r\n        var interpolatedPoints = [];\r\n        if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {\r\n            for(var i = 0; i + 2 < points.length; i = i + 2) {\r\n        if (entity.degreeOfSplineCurve === 2) {\r\n                        curve = new external_THREE_[\"QuadraticBezierCurve\"](points[i], points[i + 1], points[i + 2]);\r\n        } else {\r\n            curve = new external_THREE_[\"QuadraticBezierCurve3\"](points[i], points[i + 1], points[i + 2]);\r\n        }\r\n                interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));\r\n            }\r\n        } else {\r\n            curve = new external_THREE_[\"SplineCurve\"](points);\r\n            interpolatedPoints = curve.getPoints( 100 );\r\n        }\r\n\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( interpolatedPoints );\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]( { linewidth: 1, color : color } );\r\n        var splineObject = new external_THREE_[\"Line\"]( geometry, material );\r\n\r\n        return splineObject;\r\n    }\r\n\r\n    function drawLine(entity, data) {\r\n        var geometry = new external_THREE_[\"Geometry\"](),\r\n            color = getColor(entity, data),\r\n            material, lineType, vertex, startPoint, endPoint, bulgeGeometry,\r\n            bulge, i, line;\r\n\r\n        // create geometry\r\n        for(i = 0; i < entity.vertices.length; i++) {\r\n\r\n            if(entity.vertices[i].bulge) {\r\n                bulge = entity.vertices[i].bulge;\r\n                startPoint = entity.vertices[i];\r\n                endPoint = i + 1 < entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];\r\n\r\n                bulgeGeometry = new THREEx.BulgeGeometry(startPoint, endPoint, bulge);\r\n\r\n                geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);\r\n            } else {\r\n                vertex = entity.vertices[i];\r\n                geometry.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\r\n            }\r\n\r\n        }\r\n        if(entity.shape) geometry.vertices.push(geometry.vertices[0]);\r\n\r\n\r\n        // set material\r\n        if(entity.lineType) {\r\n            lineType = data.tables.lineType.lineTypes[entity.lineType];\r\n        }\r\n\r\n        if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n            material = new external_THREE_[\"LineDashedMaterial\"]({ color: color, gapSize: 4, dashSize: 4});\r\n        } else {\r\n            material = new external_THREE_[\"LineBasicMaterial\"]({ linewidth: 1, color: color });\r\n        }\r\n\r\n        // if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n\r\n        //           geometry.computeLineDistances();\r\n\r\n        //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we\r\n        //           // don't add diffuse to a material.\r\n        //           lineType.material.uniforms.diffuse = { type: 'c', value: new THREE.Color(color) };\r\n\r\n        // \tmaterial = new THREE.ShaderMaterial({\r\n        // \t\tuniforms: lineType.material.uniforms,\r\n        // \t\tvertexShader: lineType.material.vertexShader,\r\n        // \t\tfragmentShader: lineType.material.fragmentShader\r\n        // \t});\r\n        // }else {\r\n        // \tmaterial = new THREE.LineBasicMaterial({ linewidth: 1, color: color });\r\n        // }\r\n\r\n        line = new external_THREE_[\"Line\"](geometry, material);\r\n        return line;\r\n    }\r\n    \r\n    function drawArc(entity, data) {\r\n        var startAngle, endAngle;\r\n        if (entity.type === 'CIRCLE') {\r\n            startAngle = entity.startAngle || 0;\r\n            endAngle = startAngle + 2 * Math.PI;\r\n        } else {\r\n            startAngle = entity.startAngle;\r\n            endAngle = entity.endAngle;\r\n        }\r\n\r\n        var curve = new external_THREE_[\"ArcCurve\"](\r\n            0, 0,\r\n            entity.radius,\r\n            startAngle,\r\n            endAngle);\r\n\r\n        var points = curve.getPoints( 32 );\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\r\n\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        var arc = new external_THREE_[\"Line\"](geometry, material);\r\n        arc.position.x = entity.center.x;\r\n        arc.position.y = entity.center.y;\r\n        arc.position.z = entity.center.z;\r\n\r\n        return arc;\r\n    }\r\n\r\n    function drawSolid(entity, data) {\r\n        var material, mesh, verts,\r\n            geometry = new external_THREE_[\"Geometry\"]();\r\n\r\n        verts = geometry.vertices;\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[0].x, entity.points[0].y, entity.points[0].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[1].x, entity.points[1].y, entity.points[1].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[2].x, entity.points[2].y, entity.points[2].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[3].x, entity.points[3].y, entity.points[3].z));\r\n\r\n        // Calculate which direction the points are facing (clockwise or counter-clockwise)\r\n        var vector1 = new external_THREE_[\"Vector3\"]();\r\n        var vector2 = new external_THREE_[\"Vector3\"]();\r\n        vector1.subVectors(verts[1], verts[0]);\r\n        vector2.subVectors(verts[2], verts[0]);\r\n        vector1.cross(vector2);\r\n\r\n        // If z < 0 then we must draw these in reverse order\r\n        if(vector1.z < 0) {\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](2, 1, 0));\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](2, 3, 1));\r\n        } else {\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](0, 1, 2));\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](1, 3, 2));\r\n        }\r\n\r\n\r\n        material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        return new external_THREE_[\"Mesh\"](geometry, material);\r\n        \r\n    }\r\n\r\n    function drawText(entity, data) {\r\n        var geometry, material, text;\r\n\r\n        if(!font)\r\n            return console.warn('Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.');\r\n        \r\n        geometry = new external_THREE_[\"TextGeometry\"](entity.text, { font: font, height: 0, size: entity.textHeight || 12 });\r\n\r\n        material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        text = new external_THREE_[\"Mesh\"](geometry, material);\r\n        text.position.x = entity.startPoint.x;\r\n        text.position.y = entity.startPoint.y;\r\n        text.position.z = entity.startPoint.z;\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawPoint(entity, data) {\r\n        var geometry, material, point;\r\n\r\n        geometry = new external_THREE_[\"Geometry\"]();\r\n\r\n        geometry.vertices.push(new external_THREE_[\"Vector3\"](entity.position.x, entity.position.y, entity.position.z));\r\n\r\n        // TODO: could be more efficient. PointCloud per layer?\r\n\r\n        var numPoints = 1;\r\n\r\n        var color = getColor(entity, data);\r\n        var colors = new Float32Array( numPoints*3 );\r\n        colors[0] = color.r;\r\n        colors[1] = color.g;\r\n        colors[2] = color.b;\r\n\r\n        geometry.colors = colors;\r\n        geometry.computeBoundingBox();\r\n\r\n        material = new external_THREE_[\"PointsMaterial\"]( { size: 0.05, vertexColors: external_THREE_[\"VertexColors\"] } );\r\n        point = new external_THREE_[\"Points\"](geometry, material);\r\n        scene.add(point);\r\n    }\r\n\r\n    function drawBlock(entity, data) {\r\n        var block = data.blocks[entity.name];\r\n        \r\n        if (!block.entities) return null;\r\n\r\n        var group = new external_THREE_[\"Object3D\"]()\r\n        \r\n        if(entity.xScale) group.scale.x = entity.xScale;\r\n        if(entity.yScale) group.scale.y = entity.yScale;\r\n\r\n        if(entity.rotation) {\r\n            group.rotation.z = entity.rotation * Math.PI / 180;\r\n        }\r\n\r\n        if(entity.position) {\r\n            group.position.x = entity.position.x;\r\n            group.position.y = entity.position.y;\r\n            group.position.z = entity.position.z;\r\n        }\r\n        \r\n        for(var i = 0; i < block.entities.length; i++) {\r\n            var childEntity = drawEntity(block.entities[i], data, group);\r\n            if(childEntity) group.add(childEntity);\r\n        }\r\n\r\n        return group;\r\n    }\r\n\r\n    function getColor(entity, data) {\r\n        var color = 0x000000; //default\r\n        if(entity.color) color = entity.color;\r\n        else if(data.tables && data.tables.layer && data.tables.layer.layers[entity.layer])\r\n            color = data.tables.layer.layers[entity.layer].color;\r\n            \r\n        if(color == null || color === 0xffffff) {\r\n            color = 0x000000;\r\n        }\r\n        return color;\r\n    }\r\n\r\n    function createLineTypeShaders(data) {\r\n        var ltype, type;\r\n        if(!data.tables || !data.tables.lineType) return;\r\n        var ltypes = data.tables.lineType.lineTypes;\r\n\r\n        for(type in ltypes) {\r\n            ltype = ltypes[type];\r\n            if(!ltype.pattern) continue;\r\n            ltype.material = createDashedLineShader(ltype.pattern);\r\n        }\r\n    }\r\n\r\n    function createDashedLineShader(pattern) {\r\n        var i,\r\n            dashedLineShader = {},\r\n            totalLength = 0.0;\r\n\r\n        for(i = 0; i < pattern.length; i++) {\r\n            totalLength += Math.abs(pattern[i]);\r\n        }\r\n\r\n        dashedLineShader.uniforms = external_THREE_[\"UniformsUtils\"].merge([\r\n\r\n            external_THREE_[\"UniformsLib\"][ 'common' ],\r\n            external_THREE_[\"UniformsLib\"][ 'fog' ],\r\n\r\n            {\r\n                'pattern': { type: 'fv1', value: pattern },\r\n                'patternLength': { type: 'f', value: totalLength }\r\n            }\r\n\r\n        ]);\r\n\r\n        dashedLineShader.vertexShader = [\r\n            'attribute float lineDistance;',\r\n\r\n            'varying float vLineDistance;',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_pars_vertex' ],\r\n\r\n            'void main() {',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_vertex' ],\r\n\r\n            'vLineDistance = lineDistance;',\r\n\r\n            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n            '}'\r\n        ].join('\\n');\r\n\r\n        dashedLineShader.fragmentShader = [\r\n            'uniform vec3 diffuse;',\r\n            'uniform float opacity;',\r\n\r\n            'uniform float pattern[' + pattern.length + '];',\r\n            'uniform float patternLength;',\r\n\r\n            'varying float vLineDistance;',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_pars_fragment' ],\r\n            external_THREE_[\"ShaderChunk\"][ 'fog_pars_fragment' ],\r\n\r\n            'void main() {',\r\n\r\n            'float pos = mod(vLineDistance, patternLength);',\r\n\r\n            'for ( int i = 0; i < ' + pattern.length + '; i++ ) {',\r\n            'pos = pos - abs(pattern[i]);',\r\n            'if( pos < 0.0 ) {',\r\n            'if( pattern[i] > 0.0 ) {',\r\n            'gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );',\r\n            'break;',\r\n            '}',\r\n            'discard;',\r\n            '}',\r\n\r\n            '}',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_fragment' ],\r\n            external_THREE_[\"ShaderChunk\"][ 'fog_fragment' ],\r\n\r\n            '}'\r\n        ].join('\\n');\r\n\r\n        return dashedLineShader;\r\n    }\r\n\r\n    function findExtents(scene) { \r\n        for(var child of scene.children) {\r\n            var minX, maxX, minY, maxY;\r\n            if(child.position) {\r\n                minX = Math.min(child.position.x, minX);\r\n                minY = Math.min(child.position.y, minY);\r\n                maxX = Math.max(child.position.x, maxX);\r\n                maxY = Math.max(child.position.y, maxY);\r\n            }\r\n        }\r\n\r\n        return { min: { x: minX, y: minY }, max: { x: maxX, y: maxY }};\r\n    }\r\n\r\n}\r\n\r\n\r\n// Show/Hide helpers from https://plainjs.com/javascript/effects/hide-or-show-an-element-42/\r\n// get the default display style of an element\r\nfunction defaultDisplay(tag) {\r\n    var iframe = document.createElement('iframe');\r\n    iframe.setAttribute('frameborder', 0);\r\n    iframe.setAttribute('width', 0);\r\n    iframe.setAttribute('height', 0);\r\n    document.documentElement.appendChild(iframe);\r\n\r\n    var doc = (iframe.contentWindow || iframe.contentDocument).document;\r\n\r\n    // IE support\r\n    doc.write();\r\n    doc.close();\r\n\r\n    var testEl = doc.createElement(tag);\r\n    doc.documentElement.appendChild(testEl);\r\n    var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display\r\n    iframe.parentNode.removeChild(iframe);\r\n    return display;\r\n}\r\n\r\n// actual show/hide function used by show() and hide() below\r\nfunction showHide(el, show) {\r\n    var value = el.getAttribute('data-olddisplay'),\r\n    display = el.style.display,\r\n    computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display;\r\n\r\n    if (show) {\r\n        if (!value && display === 'none') el.style.display = '';\r\n        if (el.style.display === '' && (computedDisplay === 'none')) value = value || defaultDisplay(el.nodeName);\r\n    } else {\r\n        if (display && display !== 'none' || !(computedDisplay == 'none'))\r\n            el.setAttribute('data-olddisplay', (computedDisplay == 'none') ? display : computedDisplay);\r\n    }\r\n    if (!show || el.style.display === 'none' || el.style.display === '')\r\n        el.style.display = show ? value || '' : 'none';\r\n}\r\n\r\n// helper functions\r\nfunction show(el) { showHide(el, true); }\r\nfunction hide(el) { showHide(el); }\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi8uL3NyYy9PcmJpdENvbnRyb2xzLmpzP2UyMGYiLCJ3ZWJwYWNrOi8vVGhyZWVEeGYvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjs7QUFFeEI7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQWE7O0FBRWhDLDhCQUE4QjtBQUM5Qjs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUFhO0FBQ3BDLHFCQUFxQiwwQkFBYTtBQUNsQyx1QkFBdUIsMEJBQWE7O0FBRXBDLG9CQUFvQiwwQkFBYTtBQUNqQyxrQkFBa0IsMEJBQWE7QUFDL0Isb0JBQW9CLDBCQUFhO0FBQ2pDLHFCQUFxQiwwQkFBYTs7QUFFbEMsa0JBQWtCLDBCQUFhOztBQUUvQixzQkFBc0IsMEJBQWE7QUFDbkMsb0JBQW9CLDBCQUFhO0FBQ2pDLHNCQUFzQiwwQkFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBYTs7QUFFNUIsd0JBQXdCLDBCQUFhOztBQUVyQyxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBLEdBQUcseUNBQXlDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0VBQXNFLHdCQUF3QixFQUFFO0FBQ2hHO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsa0NBQXFCLGE7O0FDOW5COUQ7QUFBK0I7QUFDaUI7O0FBRWhEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLGNBQWMsMEJBQWE7QUFDM0IsY0FBYywwQkFBYTtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsMkJBQWM7O0FBRWYseUNBQXlDLDBCQUFhLG1DQUFtQywwQkFBYTtBQUN0RyxxQ0FBcUMsMEJBQWEsK0JBQStCLDBCQUFhO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4RkFBOEY7QUFDOUY7QUFDQTs7O0FBR0Esd0JBQXdCLDBCQUFhOztBQUVyQyxXQUFXLG1CQUFtQjs7QUFFOUI7O0FBRUEseUJBQXlCLDBCQUFhOztBQUV0Qzs7QUFFQTs7QUFFQSxnREFBZ0QsMkJBQWM7O0FBRTlEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTzs7QUFFUDs7QUFFQSxvQkFBb0Isd0JBQVc7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWM7QUFDZDtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUNBQXdCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsZ0NBQW1CO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLCtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsaUNBQW9CO0FBQy9DLDJCQUEyQixvQ0FBdUIsR0FBRywrQkFBK0I7O0FBRXBGO0FBQ0EsMEJBQTBCLHVCQUFVO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsK0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkIsb0NBQXVCLEdBQUcsYUFBYTtBQUNsRSx1QkFBdUIsdUJBQVU7O0FBRWpDO0FBQ0EsMEJBQTBCLHVCQUFVO0FBQ3BDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwwQkFBYTtBQUNwQyxTQUFTOztBQUVUO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0Esb0NBQW9DLHVDQUEwQjtBQUM5RCxTQUFTO0FBQ1Qsd0JBQXdCLHdDQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLDhCQUFpQjtBQUN6QztBQUNBOztBQUVBLDJCQUEyQixpQ0FBb0I7QUFDL0MsMkJBQTJCLG9DQUF1QixHQUFHLDhCQUE4QjtBQUNuRiwrQkFBK0IsdUJBQVU7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMkJBQWM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDRCQUE0Qjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQ0FBMkMsMEJBQWE7QUFDeEQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIscUNBQXdCLEVBQUUsdUNBQXVDO0FBQzVGLFNBQVM7QUFDVCwyQkFBMkIsb0NBQXVCLEVBQUUsNkJBQTZCO0FBQ2pGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixvREFBb0QsNkJBQTZCO0FBQ2pGOztBQUVBLG1CQUFtQix1QkFBVTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpQ0FBb0I7O0FBRS9DLDJCQUEyQixvQ0FBdUIsRUFBRSxnQ0FBZ0M7O0FBRXBGLHNCQUFzQix1QkFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUFjOztBQUV6QztBQUNBLHVCQUF1QiwwQkFBYTtBQUNwQyx1QkFBdUIsMEJBQWE7QUFDcEMsdUJBQXVCLDBCQUFhO0FBQ3BDLHVCQUF1QiwwQkFBYTs7QUFFcEM7QUFDQSwwQkFBMEIsMEJBQWE7QUFDdkMsMEJBQTBCLDBCQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUFXO0FBQy9DLG9DQUFvQyx3QkFBVztBQUMvQyxTQUFTO0FBQ1Qsb0NBQW9DLHdCQUFXO0FBQy9DLG9DQUFvQyx3QkFBVztBQUMvQzs7O0FBR0EsdUJBQXVCLG9DQUF1QixFQUFFLGdDQUFnQzs7QUFFaEYsbUJBQW1CLHVCQUFVOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLCtCQUFrQixlQUFlLHVEQUF1RDs7QUFFL0csdUJBQXVCLG9DQUF1QixFQUFFLGdDQUFnQzs7QUFFaEYsbUJBQW1CLHVCQUFVO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLDJCQUFjOztBQUVyQyxtQ0FBbUMsMEJBQWE7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsaUNBQW9CLEdBQUcsMkJBQTJCLCtCQUFrQixFQUFFO0FBQzdGLG9CQUFvQix5QkFBWTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLDJCQUFjOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBLG9DQUFvQyxnQ0FBbUI7O0FBRXZELFlBQVksOEJBQWlCO0FBQzdCLFlBQVksOEJBQWlCOztBQUU3QjtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQsa0NBQWtDO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQyx5Q0FBeUM7O0FBRXpDLFlBQVksOEJBQWlCOztBQUU3QiwwQkFBMEI7O0FBRTFCLFlBQVksOEJBQWlCOztBQUU3QiwwQ0FBMEM7O0FBRTFDLHNGQUFzRjs7QUFFdEYsY0FBYztBQUNkOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLG1DQUFtQzs7QUFFbkMsMkRBQTJEO0FBQzNELHlDQUF5Qzs7QUFFekMseUNBQXlDOztBQUV6QyxZQUFZLDhCQUFpQjtBQUM3QixZQUFZLDhCQUFpQjs7QUFFN0IsMEJBQTBCOztBQUUxQiwyREFBMkQ7O0FBRTNELDZCQUE2Qiw0QkFBNEIsUUFBUTtBQUNqRSx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLHFDQUFxQztBQUNyQywwREFBMEQ7QUFDMUQsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsY0FBYzs7QUFFZCxjQUFjOztBQUVkLFlBQVksOEJBQWlCO0FBQzdCLFlBQVksOEJBQWlCOztBQUU3QixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQSxpQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsT0FBTyxtQkFBbUIsUUFBUTtBQUNsRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLGNBQWMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGVyaWNoNjY2IC8gaHR0cDovL2VyaWNoYWluZXMuY29tXHJcbiAqL1xyXG4vKmdsb2JhbCBUSFJFRSwgY29uc29sZSAqL1xyXG5cclxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xyXG4vLyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBhcyArWSwgdW5saWtlIHRoZSBUcmFja2JhbGxDb250cm9scy4gVG91Y2ggb24gdGFibGV0IGFuZCBwaG9uZXMgaXNcclxuLy8gc3VwcG9ydGVkLlxyXG4vL1xyXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lIGZpbmdlciBtb3ZlXHJcbi8vICAgIFpvb20gLSBtaWRkbGUgbW91c2UsIG9yIG1vdXNld2hlZWwgLyB0b3VjaDogdHdvIGZpbmdlciBzcHJlYWQgb3Igc3F1aXNoXHJcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxyXG4vL1xyXG4vLyBUaGlzIGlzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgKG1vc3QpIFRyYWNrYmFsbENvbnRyb2xzIHVzZWQgaW4gZXhhbXBsZXMuXHJcbi8vIFRoYXQgaXMsIGluY2x1ZGUgdGhpcyBqcyBmaWxlIGFuZCB3aGVyZXZlciB5b3Ugc2VlOlxyXG4vLyAgICBcdGNvbnRyb2xzID0gbmV3IFRIUkVFLlRyYWNrYmFsbENvbnRyb2xzKCBjYW1lcmEgKTtcclxuLy8gICAgICBjb250cm9scy50YXJnZXQueiA9IDE1MDtcclxuLy8gU2ltcGxlIHN1YnN0aXR1dGUgXCJPcmJpdENvbnRyb2xzXCIgYW5kIHRoZSBjb250cm9sIHNob3VsZCB3b3JrIGFzLWlzLlxyXG5cclxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE9yYml0Q29udHJvbHMoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0dGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcclxuXHJcblx0Ly8gQVBJXHJcblxyXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxyXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcclxuXHQvLyBhbmQgd2hlcmUgaXQgcGFucyB3aXRoIHJlc3BlY3QgdG8uXHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHQvLyBjZW50ZXIgaXMgb2xkLCBkZXByZWNhdGVkOyB1c2UgXCJ0YXJnZXRcIiBpbnN0ZWFkXHJcblx0dGhpcy5jZW50ZXIgPSB0aGlzLnRhcmdldDtcclxuXHJcblx0Ly8gVGhpcyBvcHRpb24gYWN0dWFsbHkgZW5hYmxlcyBkb2xseWluZyBpbiBhbmQgb3V0OyBsZWZ0IGFzIFwiem9vbVwiIGZvclxyXG5cdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0dGhpcy5ub1pvb20gPSBmYWxzZTtcclxuXHR0aGlzLnpvb21TcGVlZCA9IDEuMDtcclxuXHJcblx0Ly8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0XHJcblx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XHJcblx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xyXG5cclxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxyXG5cdHRoaXMubm9Sb3RhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xyXG5cclxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxyXG5cdHRoaXMubm9QYW4gPSBmYWxzZTtcclxuXHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxyXG5cclxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxyXG5cdHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciByb3VuZCB3aGVuIGZwcyBpcyA2MFxyXG5cclxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cclxuXHQvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cclxuXHR0aGlzLm1pblBvbGFyQW5nbGUgPSAwOyAvLyByYWRpYW5zXHJcblx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xyXG5cclxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xyXG5cdHRoaXMubm9LZXlzID0gZmFsc2U7XHJcblxyXG5cdC8vIFRoZSBmb3VyIGFycm93IGtleXNcclxuXHR0aGlzLmtleXMgPSB7IExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgQk9UVE9NOiA0MCB9O1xyXG5cclxuXHQvLy8vLy8vLy8vLy9cclxuXHQvLyBpbnRlcm5hbHNcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuXHR2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciByb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdHZhciBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHBhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHBhbkRlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcGFuT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBkb2xseVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgZG9sbHlFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBkb2xseURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0dmFyIHBoaURlbHRhID0gMDtcclxuXHR2YXIgdGhldGFEZWx0YSA9IDA7XHJcblx0dmFyIHNjYWxlID0gMTtcclxuXHR2YXIgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBTVEFURSA9IHsgTk9ORSA6IC0xLCBST1RBVEUgOiAwLCBET0xMWSA6IDEsIFBBTiA6IDIsIFRPVUNIX1JPVEFURSA6IDMsIFRPVUNIX0RPTExZIDogNCwgVE9VQ0hfUEFOIDogNSB9O1xyXG5cclxuXHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHQvLyBmb3IgcmVzZXRcclxuXHJcblx0dGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcclxuXHR0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XHJcblxyXG5cdC8vIGV2ZW50c1xyXG5cclxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XHJcblx0dmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCd9O1xyXG5cdHZhciBlbmRFdmVudCA9IHsgdHlwZTogJ2VuZCd9O1xyXG5cclxuXHR0aGlzLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhldGFEZWx0YSAtPSBhbmdsZTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yb3RhdGVVcCA9IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0YW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwaGlEZWx0YSAtPSBhbmdsZTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gcGFzcyBpbiBkaXN0YW5jZSBpbiB3b3JsZCBzcGFjZSB0byBtb3ZlIGxlZnRcclxuXHR0aGlzLnBhbkxlZnQgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcclxuXHJcblx0XHQvLyBnZXQgWCBjb2x1bW4gb2YgbWF0cml4XHJcblx0XHRwYW5PZmZzZXQuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XHJcblx0XHRwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcclxuXHRcdFxyXG5cdFx0cGFuLmFkZCggcGFuT2Zmc2V0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxyXG5cdHRoaXMucGFuVXAgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcclxuXHJcblx0XHQvLyBnZXQgWSBjb2x1bW4gb2YgbWF0cml4XHJcblx0XHRwYW5PZmZzZXQuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XHJcblx0XHRwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICk7XHJcblx0XHRcclxuXHRcdHBhbi5hZGQoIHBhbk9mZnNldCApO1xyXG5cclxuXHR9O1xyXG5cdFxyXG5cdC8vIHBhc3MgaW4geCx5IG9mIGNoYW5nZSBkZXNpcmVkIGluIHBpeGVsIHNwYWNlLFxyXG5cdC8vIHJpZ2h0IGFuZCBkb3duIGFyZSBwb3NpdGl2ZVxyXG5cdHRoaXMucGFuID0gZnVuY3Rpb24gKCBkZWx0YVgsIGRlbHRhWSApIHtcclxuXHJcblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcclxuXHJcblx0XHRpZiAoIHNjb3BlLm9iamVjdC5mb3YgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIHBlcnNwZWN0aXZlXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcclxuXHRcdFx0dmFyIG9mZnNldCA9IHBvc2l0aW9uLmNsb25lKCkuc3ViKCBzY29wZS50YXJnZXQgKTtcclxuXHRcdFx0dmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXHJcblx0XHRcdHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCAoIHNjb3BlLm9iamVjdC5mb3YgLyAyICkgKiBNYXRoLlBJIC8gMTgwLjAgKTtcclxuXHJcblx0XHRcdC8vIHdlIGFjdHVhbGx5IGRvbid0IHVzZSBzY3JlZW5XaWR0aCwgc2luY2UgcGVyc3BlY3RpdmUgY2FtZXJhIGlzIGZpeGVkIHRvIHNjcmVlbiBoZWlnaHRcclxuXHRcdFx0c2NvcGUucGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcclxuXHRcdFx0c2NvcGUucGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBcclxuXHRcdFx0Ly8gb3J0aG9ncmFwaGljXHJcblx0XHRcdHNjb3BlLnBhbkxlZnQoIGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBlbGVtZW50LmNsaWVudFdpZHRoICk7XHJcblx0XHRcdHNjb3BlLnBhblVwKCBkZWx0YVkgKiAoc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20pIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG9yIHBlcnNwZWN0aXZlXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmRvbGx5SW4gPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBkb2xseVNjYWxlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZG9sbHlPdXQgPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBkb2xseVNjYWxlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHNjb3BlLm9iamVjdC50b3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC50b3AgPSAoc2NhbGUqdGhpcy5vYmplY3QudG9wKTtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3QuYm90dG9tID0gKHNjYWxlKnRoaXMub2JqZWN0LmJvdHRvbSk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmxlZnQgPSAoc2NhbGUqdGhpcy5vYmplY3QubGVmdCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnJpZ2h0ID0gKHNjYWxlKnRoaXMub2JqZWN0LnJpZ2h0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcclxuXHJcblx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHRoaXMudGFyZ2V0ICk7XHJcbi8vXHJcbi8vXHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcclxuLy9cclxuLy9cdFx0dmFyIHRoZXRhID0gTWF0aC5hdGFuMiggb2Zmc2V0LngsIG9mZnNldC56ICk7XHJcbi8vXHJcbi8vXHRcdC8vIGFuZ2xlIGZyb20geS1heGlzXHJcbi8vXHJcbi8vXHRcdHZhciBwaGkgPSBNYXRoLmF0YW4yKCBNYXRoLnNxcnQoIG9mZnNldC54ICogb2Zmc2V0LnggKyBvZmZzZXQueiAqIG9mZnNldC56ICksIG9mZnNldC55ICk7XHJcbi8vXHJcbi8vXHRcdGlmICggdGhpcy5hdXRvUm90YXRlICkge1xyXG4vL1xyXG4vL1x0XHRcdHRoaXMucm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xyXG4vL1xyXG4vL1x0XHR9XHJcbi8vXHJcbi8vXHRcdHRoZXRhICs9IHRoZXRhRGVsdGE7XHJcbi8vXHRcdHBoaSArPSBwaGlEZWx0YTtcclxuLy9cclxuLy9cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcclxuLy9cdFx0cGhpID0gTWF0aC5tYXgoIHRoaXMubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHRoaXMubWF4UG9sYXJBbmdsZSwgcGhpICkgKTtcclxuLy9cclxuLy9cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xyXG4vL1x0XHRwaGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgcGhpICkgKTtcclxuLy9cclxuLy9cdFx0dmFyIHJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKSAqIHNjYWxlO1xyXG4vL1xyXG4vL1x0XHQvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xyXG4vL1x0XHRyYWRpdXMgPSBNYXRoLm1heCggdGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cyApICk7XHJcbi8vXHRcdFxyXG4vL1x0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cclxuXHRcdHRoaXMudGFyZ2V0LmFkZCggcGFuICk7XHJcbi8vXHRcdFxyXG4vL1x0XHRvZmZzZXQueCA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguc2luKCB0aGV0YSApO1xyXG4vL1x0XHRvZmZzZXQueSA9IHJhZGl1cyAqIE1hdGguY29zKCBwaGkgKTtcclxuLy9cdFx0b2Zmc2V0LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpICkgKiBNYXRoLmNvcyggdGhldGEgKTtcclxuLy9cclxuXHRcdHBvc2l0aW9uLmNvcHkoIHRoaXMudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHR0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XHJcblxyXG5cclxuLy9cdFx0aWYgKCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUbyggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IDAgfHwgc2NhbGUgIT09IDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XHJcblxyXG4vL1x0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xyXG5cclxuLy9cdFx0fVxyXG4gICAgICAgIFxyXG4vLyAgICAgICAgdGhldGFEZWx0YSA9IDA7XHJcbi8vXHRcdHBoaURlbHRhID0gMDtcclxuXHRcdHNjYWxlID0gMTtcclxuXHRcdHBhbi5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0LmNvcHkoIHRoaXMudGFyZ2V0MCApO1xyXG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbjAgKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMCApIHtcclxuXHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xyXG5cclxuXHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSAxICkge1xyXG5cdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdHN0YXRlID0gU1RBVEUuRE9MTFk7XHJcblxyXG5cdFx0XHRkb2xseVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMiApIHtcclxuXHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xyXG5cclxuXHRcdFx0cGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xyXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xyXG5cclxuXHRcdGlmICggc3RhdGUgPT09IFNUQVRFLlJPVEFURSApIHtcclxuXHJcblx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcclxuXHJcblx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcclxuXHRcdFx0c2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcclxuXHRcdFx0c2NvcGUucm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcclxuXHJcblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5ET0xMWSApIHtcclxuXHJcblx0XHRcdGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcclxuXHJcblx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZG9sbHlJbigpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZG9sbHlPdXQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuUEFOICkge1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdHBhbkVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcclxuXHRcdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xyXG5cdFx0XHRcclxuXHRcdFx0c2NvcGUucGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XHJcblxyXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Nb3VzZVVwKCAvKiBldmVudCAqLyApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xyXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XHJcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdHZhciBkZWx0YSA9IDA7XHJcblxyXG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICE9PSB1bmRlZmluZWQgKSB7IC8vIFdlYktpdCAvIE9wZXJhIC8gRXhwbG9yZXIgOVxyXG5cclxuXHRcdFx0ZGVsdGEgPSBldmVudC53aGVlbERlbHRhO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmRldGFpbCAhPT0gdW5kZWZpbmVkICkgeyAvLyBGaXJlZm94XHJcblxyXG5cdFx0XHRkZWx0YSA9IC0gZXZlbnQuZGV0YWlsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRlbHRhID4gMCApIHtcclxuXHJcblx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub0tleXMgPT09IHRydWUgfHwgc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblx0XHRcclxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuVVA6XHJcblx0XHRcdFx0c2NvcGUucGFuKCAwLCBzY29wZS5rZXlQYW5TcGVlZCApO1xyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcclxuXHRcdFx0XHRzY29wZS5wYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxyXG5cdFx0XHRcdHNjb3BlLnBhbiggc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcclxuXHRcdFx0XHRzY29wZS5wYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG91Y2hzdGFydCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGNhc2UgMTpcdC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xyXG5cclxuXHRcdFx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDI6XHQvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZO1xyXG5cclxuXHRcdFx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XHJcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcclxuXHRcdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcclxuXHJcblx0XHRcdFx0cGFuU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG91Y2htb3ZlKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcclxuXHJcblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XHJcblx0XHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xyXG5cclxuXHRcdFx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXHJcblx0XHRcdFx0c2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblx0XHRcdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXHJcblx0XHRcdFx0c2NvcGUucm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcclxuXHJcblx0XHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xyXG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XHJcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcclxuXHJcblx0XHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xyXG5cdFx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUuZG9sbHlJbigpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdHBhbkVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XHJcblx0XHRcdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xyXG5cclxuXHRcdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvdWNoZW5kKCAvKiBldmVudCAqLyApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XHJcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIGZ1bmN0aW9uICggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0sIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcclxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Nb3VzZVNjcm9sbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTsgLy8gZmlyZWZveFxyXG5cclxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UgKTtcclxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UgKTtcclxuXHJcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xyXG5cclxufTtcclxuXHJcbk9yYml0Q29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApOyIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgT3JiaXRDb250cm9scyB9IGZyb20gJy4vT3JiaXRDb250cm9scyc7XHJcblxyXG4vLyBUaHJlZS5qcyBleHRlbnNpb24gZnVuY3Rpb25zLiBXZWJwYWNrIGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0IGlmIHdlIG1vZGlmeSB0aGUgVEhSRUUgb2JqZWN0IGRpcmVjdGx5LlxyXG52YXIgVEhSRUV4ID0geyBNYXRoOiB7fSB9O1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucyBvZiB0aGUgdmVjdG9yIChwMSxwMikuIEluIG90aGVyIHdvcmRzLCBpbWFnaW5lXHJcbiAqIHB1dHRpbmcgdGhlIGJhc2Ugb2YgdGhlIHZlY3RvciBhdCBjb29yZGluYXRlcyAoMCwwKSBhbmQgZmluZGluZyB0aGUgYW5nbGVcclxuICogZnJvbSB2ZWN0b3IgKDEsMCkgdG8gKHAxLHAyKS5cclxuICogQHBhcmFtICB7T2JqZWN0fSBwMSBzdGFydCBwb2ludCBvZiB0aGUgdmVjdG9yXHJcbiAqIEBwYXJhbSAge09iamVjdH0gcDIgZW5kIHBvaW50IG9mIHRoZSB2ZWN0b3JcclxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgYW5nbGVcclxuICovXHJcblRIUkVFeC5NYXRoLmFuZ2xlMiA9IGZ1bmN0aW9uKHAxLCBwMikge1xyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKHAxLngsIHAxLnkpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKHAyLngsIHAyLnkpO1xyXG5cdHYyLnN1Yih2MSk7IC8vIHNldHMgdjIgdG8gYmUgb3VyIGNob3JkXHJcblx0djIubm9ybWFsaXplKCk7XHJcblx0aWYodjIueSA8IDApIHJldHVybiAtTWF0aC5hY29zKHYyLngpO1xyXG5cdHJldHVybiBNYXRoLmFjb3ModjIueCk7XHJcbn07XHJcblxyXG5cclxuVEhSRUV4Lk1hdGgucG9sYXIgPSBmdW5jdGlvbihwb2ludCwgZGlzdGFuY2UsIGFuZ2xlKSB7XHJcblx0dmFyIHJlc3VsdCA9IHt9O1xyXG5cdHJlc3VsdC54ID0gcG9pbnQueCArIGRpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpO1xyXG5cdHJlc3VsdC55ID0gcG9pbnQueSArIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBwb2ludHMgZm9yIGEgY3VydmUgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqIEBwYXJhbSBzdGFydFBvaW50IC0gdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBjdXJ2ZVxyXG4gKiBAcGFyYW0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBjdXJ2ZVxyXG4gKiBAcGFyYW0gYnVsZ2UgLSBhIHZhbHVlIGluZGljYXRpbmcgaG93IG11Y2ggdG8gY3VydmVcclxuICogQHBhcmFtIHNlZ21lbnRzIC0gbnVtYmVyIG9mIHNlZ21lbnRzIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb2ludHNcclxuICovXHJcblRIUkVFeC5CdWxnZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzdGFydFBvaW50LCBlbmRQb2ludCwgYnVsZ2UsIHNlZ21lbnRzICkge1xyXG5cclxuXHR2YXIgdmVydGV4LCBpLFxyXG5cdFx0Y2VudGVyLCBwMCwgcDEsIGFuZ2xlLFxyXG5cdFx0cmFkaXVzLCBzdGFydEFuZ2xlLFxyXG5cdFx0dGhldGFBbmdsZTtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnN0YXJ0UG9pbnQgPSBwMCA9IHN0YXJ0UG9pbnQgPyBuZXcgVEhSRUUuVmVjdG9yMihzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSkgOiBuZXcgVEhSRUUuVmVjdG9yMigwLDApO1xyXG5cdHRoaXMuZW5kUG9pbnQgPSBwMSA9IGVuZFBvaW50ID8gbmV3IFRIUkVFLlZlY3RvcjIoZW5kUG9pbnQueCwgZW5kUG9pbnQueSkgOiBuZXcgVEhSRUUuVmVjdG9yMigxLDApO1xyXG5cdHRoaXMuYnVsZ2UgPSBidWxnZSA9IGJ1bGdlIHx8IDE7XHJcblxyXG5cdGFuZ2xlID0gNCAqIE1hdGguYXRhbihidWxnZSk7XHJcblx0cmFkaXVzID0gcDAuZGlzdGFuY2VUbyhwMSkgLyAyIC8gTWF0aC5zaW4oYW5nbGUvMik7XHJcblx0Y2VudGVyID0gVEhSRUV4Lk1hdGgucG9sYXIoc3RhcnRQb2ludCwgcmFkaXVzLCBUSFJFRXguTWF0aC5hbmdsZTIocDAscDEpICsgKE1hdGguUEkgLyAyIC0gYW5nbGUvMikpO1xyXG5cclxuXHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHMgPSBzZWdtZW50cyB8fCBNYXRoLm1heCggTWF0aC5hYnMoTWF0aC5jZWlsKGFuZ2xlLyhNYXRoLlBJLzE4KSkpLCA2KTsgLy8gQnkgZGVmYXVsdCB3YW50IGEgc2VnbWVudCByb3VnaGx5IGV2ZXJ5IDEwIGRlZ3JlZXNcclxuXHRzdGFydEFuZ2xlID0gVEhSRUV4Lk1hdGguYW5nbGUyKGNlbnRlciwgcDApO1xyXG5cdHRoZXRhQW5nbGUgPSBhbmdsZSAvIHNlZ21lbnRzO1xyXG5cclxuXHJcblx0dGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHAwLngsIHAwLnksIDApKTtcclxuXHJcblx0Zm9yKGkgPSAxOyBpIDw9IHNlZ21lbnRzIC0gMTsgaSsrKSB7XHJcblxyXG5cdFx0dmVydGV4ID0gVEhSRUV4Lk1hdGgucG9sYXIoY2VudGVyLCBNYXRoLmFicyhyYWRpdXMpLCBzdGFydEFuZ2xlICsgdGhldGFBbmdsZSAqIGkpO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0ZXgueCwgdmVydGV4LnksIDApKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFeC5CdWxnZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4gICAgXHJcbi8qKlxyXG4gKiBWaWV3ZXIgY2xhc3MgZm9yIGEgZHhmIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0aGUgZHhmIG9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IC0gdGhlIHBhcmVudCBlbGVtZW50IHRvIHdoaWNoIHdlIGF0dGFjaCB0aGUgcmVuZGVyaW5nIGNhbnZhc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSB3aWR0aCBvZiB0aGUgcmVuZGVyaW5nIGNhbnZhcyBpbiBwaXhlbHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIGhlaWdodCBvZiB0aGUgcmVuZGVyaW5nIGNhbnZhcyBpbiBwaXhlbHNcclxuICogQHBhcmFtIHtPYmplY3R9IGZvbnQgLSBhIGZvbnQgbG9hZGVkIHdpdGggVEhSRUUuRm9udExvYWRlciBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld2VyKGRhdGEsIHBhcmVudCwgd2lkdGgsIGhlaWdodCwgZm9udCkge1xyXG5cclxuICAgIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKTtcclxuXHJcbiAgICB2YXIgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgc2NlbmUgZnJvbSBkeGYgb2JqZWN0IChkYXRhKVxyXG4gICAgdmFyIGksIGVudGl0eSwgb2JqLCBtaW5feCwgbWluX3ksIG1pbl96LCBtYXhfeCwgbWF4X3ksIG1heF96O1xyXG4gICAgdmFyIGRpbXMgPSB7XHJcbiAgICAgICAgbWluOiB7IHg6IGZhbHNlLCB5OiBmYWxzZSwgejogZmFsc2V9LFxyXG4gICAgICAgIG1heDogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlfVxyXG4gICAgfTtcclxuICAgIGZvcihpID0gMDsgaSA8IGRhdGEuZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlbnRpdHkgPSBkYXRhLmVudGl0aWVzW2ldO1xyXG5cclxuICAgICAgICBpZihlbnRpdHkudHlwZSA9PT0gJ0RJTUVOU0lPTicpIHtcclxuICAgICAgICAgICAgaWYoZW50aXR5LmJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLmJsb2Nrc1tlbnRpdHkuYmxvY2tdO1xyXG4gICAgICAgICAgICAgICAgaWYoIWJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyByZWZlcmVuY2VkIGJsb2NrIFwiJyArIGVudGl0eS5ibG9jayArICdcIicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGJsb2NrLmVudGl0aWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZHJhd0VudGl0eShibG9jay5lbnRpdGllc1tqXSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogTm8gYmxvY2sgZm9yIERJTUVOU0lPTiBlbnRpdHknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9iaiA9IGRyYXdFbnRpdHkoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21PYmplY3Qob2JqKTtcclxuICAgICAgICAgICAgaWYgKGJib3gubWluLnggJiYgKChkaW1zLm1pbi54ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnggPiBiYm94Lm1pbi54KSkpIGRpbXMubWluLnggPSBiYm94Lm1pbi54O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueSAmJiAoKGRpbXMubWluLnkgPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueSA+IGJib3gubWluLnkpKSkgZGltcy5taW4ueSA9IGJib3gubWluLnk7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1pbi56ICYmICgoZGltcy5taW4ueiA9PT0gZmFsc2UpIHx8IChkaW1zLm1pbi56ID4gYmJveC5taW4ueikpKSBkaW1zLm1pbi56ID0gYmJveC5taW4uejtcclxuICAgICAgICAgICAgaWYgKGJib3gubWF4LnggJiYgKChkaW1zLm1heC54ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnggPCBiYm94Lm1heC54KSkpIGRpbXMubWF4LnggPSBiYm94Lm1heC54O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueSAmJiAoKGRpbXMubWF4LnkgPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueSA8IGJib3gubWF4LnkpKSkgZGltcy5tYXgueSA9IGJib3gubWF4Lnk7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1heC56ICYmICgoZGltcy5tYXgueiA9PT0gZmFsc2UpIHx8IChkaW1zLm1heC56IDwgYmJveC5tYXgueikpKSBkaW1zLm1heC56ID0gYmJveC5tYXguejtcclxuICAgICAgICAgICAgc2NlbmUuYWRkKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgd2lkdGggPSB3aWR0aCB8fCBwYXJlbnQuaW5uZXJXaWR0aDtcclxuICAgIGhlaWdodCA9IGhlaWdodCB8fCBwYXJlbnQuaW5uZXJIZWlnaHQ7XHJcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcclxuXHJcbiAgICB2YXIgdXBwZXJSaWdodENvcm5lciA9IHsgeDogZGltcy5tYXgueCwgeTogZGltcy5tYXgueSB9O1xyXG4gICAgdmFyIGxvd2VyTGVmdENvcm5lciA9IHsgeDogZGltcy5taW4ueCwgeTogZGltcy5taW4ueSB9O1xyXG5cclxuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGN1cnJlbnQgdmlld3BvcnQgZXh0ZW50c1xyXG4gICAgdmFyIHZwX3dpZHRoID0gdXBwZXJSaWdodENvcm5lci54IC0gbG93ZXJMZWZ0Q29ybmVyLng7XHJcbiAgICB2YXIgdnBfaGVpZ2h0ID0gdXBwZXJSaWdodENvcm5lci55IC0gbG93ZXJMZWZ0Q29ybmVyLnk7XHJcbiAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHtcclxuICAgICAgICB4OiB2cF93aWR0aCAvIDIgKyBsb3dlckxlZnRDb3JuZXIueCxcclxuICAgICAgICB5OiB2cF9oZWlnaHQgLyAyICsgbG93ZXJMZWZ0Q29ybmVyLnlcclxuICAgIH07XHJcblxyXG4gICAgLy8gRml0IGFsbCBvYmplY3RzIGludG8gY3VycmVudCBUaHJlZURYRiB2aWV3ZXJcclxuICAgIHZhciBleHRlbnRzQXNwZWN0UmF0aW8gPSBNYXRoLmFicyh2cF93aWR0aCAvIHZwX2hlaWdodCk7XHJcbiAgICBpZiAoYXNwZWN0UmF0aW8gPiBleHRlbnRzQXNwZWN0UmF0aW8pIHtcclxuICAgICAgICB2cF93aWR0aCA9IHZwX2hlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2cF9oZWlnaHQgPSB2cF93aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgdmlld1BvcnQgPSB7XHJcbiAgICAgICAgYm90dG9tOiAtdnBfaGVpZ2h0IC8gMixcclxuICAgICAgICBsZWZ0OiAtdnBfd2lkdGggLyAyLFxyXG4gICAgICAgIHRvcDogdnBfaGVpZ2h0IC8gMixcclxuICAgICAgICByaWdodDogdnBfd2lkdGggLyAyLFxyXG4gICAgICAgIGNlbnRlcjoge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogY2VudGVyLnlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKHZpZXdQb3J0LmxlZnQsIHZpZXdQb3J0LnJpZ2h0LCB2aWV3UG9ydC50b3AsIHZpZXdQb3J0LmJvdHRvbSwgMSwgMTkpO1xyXG4gICAgY2FtZXJhLnBvc2l0aW9uLnogPSAxMDtcclxuICAgIGNhbWVyYS5wb3NpdGlvbi54ID0gdmlld1BvcnQuY2VudGVyLng7XHJcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IHZpZXdQb3J0LmNlbnRlci55O1xyXG5cclxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcclxuXHJcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcbiAgICBwYXJlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblxyXG4gICAgLy9UT0RPOiBOZWVkIHRvIG1ha2UgdGhpcyBhbiBvcHRpb24gc29tZWhvdyBzbyBvdGhlcnMgY2FuIHJvbGwgdGhlaXIgb3duIGNvbnRyb2xzLlxyXG4gICAgdmFyIGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCBwYXJlbnQpO1xyXG4gICAgY29udHJvbHMudGFyZ2V0LnggPSBjYW1lcmEucG9zaXRpb24ueDtcclxuICAgIGNvbnRyb2xzLnRhcmdldC55ID0gY2FtZXJhLnBvc2l0aW9uLnk7XHJcbiAgICBjb250cm9scy50YXJnZXQueiA9IDA7XHJcbiAgICBjb250cm9scy56b29tU3BlZWQgPSAzO1xyXG5cclxuICAgIC8vVW5jb21tZW50IHRoaXMgdG8gZGlzYWJsZSByb3RhdGlvbiAoZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIHdpdGggMkQgZHJhd2luZ3MpLlxyXG4gICAgLy9jb250cm9scy5lbmFibGVSb3RhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkgeyByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSkgfTtcclxuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMucmVuZGVyKTtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICBjb250cm9scy51cGRhdGUoKTtcclxuXHJcbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gcmVuZGVyZXIuZG9tRWxlbWVudC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBoc2NhbGUgPSB3aWR0aCAvIG9yaWdpbmFsV2lkdGg7XHJcbiAgICAgICAgdmFyIHZzY2FsZSA9IGhlaWdodCAvIG9yaWdpbmFsSGVpZ2h0O1xyXG5cclxuXHJcbiAgICAgICAgY2FtZXJhLnRvcCA9ICh2c2NhbGUgKiBjYW1lcmEudG9wKTtcclxuICAgICAgICBjYW1lcmEuYm90dG9tID0gKHZzY2FsZSAqIGNhbWVyYS5ib3R0b20pO1xyXG4gICAgICAgIGNhbWVyYS5sZWZ0ID0gKGhzY2FsZSAqIGNhbWVyYS5sZWZ0KTtcclxuICAgICAgICBjYW1lcmEucmlnaHQgPSAoaHNjYWxlICogY2FtZXJhLnJpZ2h0KTtcclxuXHJcbi8vICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RW50aXR5KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBtZXNoO1xyXG4gICAgICAgIGlmKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0FSQycpIHtcclxuICAgICAgICAgICAgbWVzaCA9IGRyYXdBcmMoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdMV1BPTFlMSU5FJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0xJTkUnIHx8IGVudGl0eS50eXBlID09PSAnUE9MWUxJTkUnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3TGluZShlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1RFWFQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3VGV4dChlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1NPTElEJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnUE9JTlQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3UG9pbnQoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdJTlNFUlQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3QmxvY2soZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdTUExJTkUnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3U3BsaW5lKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnTVRFWFQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3TXRleHQoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdFTExJUFNFJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd0VsbGlwc2UoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zdXBwb3J0ZWQgRW50aXR5IFR5cGU6IFwiICsgZW50aXR5LnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RWxsaXBzZShlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xyXG5cclxuICAgICAgICB2YXIgeHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueCwyKSArIE1hdGgucG93KGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC55LDIpKTtcclxuICAgICAgICB2YXIgeXJhZCA9IHhyYWQqZW50aXR5LmF4aXNSYXRpbztcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLmF0YW4yKGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC55LCBlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueCk7XHJcblxyXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoXHJcbiAgICAgICAgICAgIGVudGl0eS5jZW50ZXIueCwgIGVudGl0eS5jZW50ZXIueSxcclxuICAgICAgICAgICAgeHJhZCwgeXJhZCxcclxuICAgICAgICAgICAgZW50aXR5LnN0YXJ0QW5nbGUsIGVudGl0eS5lbmRBbmdsZSxcclxuICAgICAgICAgICAgZmFsc2UsIC8vIEFsd2F5cyBjb3VudGVyY2xvY2t3aXNlXHJcbiAgICAgICAgICAgIHJvdGF0aW9uXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGN1cnZlLmdldFBvaW50cyggNTAgKTtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgIGxpbmV3aWR0aDogMSwgY29sb3IgOiBjb2xvciB9ICk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb2JqZWN0IHRvIGFkZCB0byB0aGUgc2NlbmVcclxuICAgICAgICB2YXIgZWxsaXBzZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuICAgICAgICByZXR1cm4gZWxsaXBzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3TXRleHQoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeSggZW50aXR5LnRleHQsIHtcclxuICAgICAgICAgICAgZm9udDogZm9udCxcclxuICAgICAgICAgICAgc2l6ZTogZW50aXR5LmhlaWdodCAqICg0LzUpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtjb2xvcjogY29sb3J9ICk7XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIC8vIE1lYXN1cmUgd2hhdCB3ZSByZW5kZXJlZC5cclxuICAgICAgICB2YXIgbWVhc3VyZSA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcbiAgICAgICAgbWVhc3VyZS5zZXRGcm9tT2JqZWN0KCB0ZXh0ICk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0V2lkdGggID0gbWVhc3VyZS5tYXgueCAtIG1lYXN1cmUubWluLng7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSB0ZXh0IGVuZHMgdXAgYmVpbmcgd2lkZXIgdGhhbiB0aGUgYm94LCBpdCdzIHN1cHBvc2VkXHJcbiAgICAgICAgLy8gdG8gYmUgbXVsdGlsaW5lLiBEb2luZyB0aGF0IGluIHRocmVlSlMgaXMgb3ZlcmtpbGwuXHJcbiAgICAgICAgaWYgKHRleHRXaWR0aCA+IGVudGl0eS53aWR0aCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbid0IHJlbmRlciB0aGlzIG11bHRpcGxpbmUgTVRFWFQgZW50aXR5LCBzb3JyeS5cIiwgZW50aXR5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRleHQucG9zaXRpb24ueiA9IDA7XHJcbiAgICAgICAgc3dpdGNoIChlbnRpdHkuYXR0YWNobWVudFBvaW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIC8vIFRvcCBMZWZ0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIC8vIFRvcCBDZW50ZXJcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAvLyBUb3AgUmlnaHRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBMZWZ0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodC8yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgLy8gTWlkZGxlIENlbnRlclxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodC8yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgLy8gTWlkZGxlIFJpZ2h0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodC8yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBMZWZ0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIENlbnRlclxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTcGxpbmUoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGVudGl0eS5jb250cm9sUG9pbnRzLm1hcChmdW5jdGlvbih2ZWMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHZlYy54LCB2ZWMueSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZWRQb2ludHMgPSBbXTtcclxuICAgICAgICBpZiAoZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDIgfHwgZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDMpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSArIDIgPCBwb2ludHMubGVuZ3RoOyBpID0gaSArIDIpIHtcclxuICAgICAgICBpZiAoZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRQb2ludHMucHVzaC5hcHBseShpbnRlcnBvbGF0ZWRQb2ludHMsIGN1cnZlLmdldFBvaW50cyg1MCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUocG9pbnRzKTtcclxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkUG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCAxMDAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIGludGVycG9sYXRlZFBvaW50cyApO1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xyXG4gICAgICAgIHZhciBzcGxpbmVPYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIHJldHVybiBzcGxpbmVPYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0xpbmUoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcbiAgICAgICAgICAgIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSxcclxuICAgICAgICAgICAgbWF0ZXJpYWwsIGxpbmVUeXBlLCB2ZXJ0ZXgsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBidWxnZUdlb21ldHJ5LFxyXG4gICAgICAgICAgICBidWxnZSwgaSwgbGluZTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGdlb21ldHJ5XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgZW50aXR5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZihlbnRpdHkudmVydGljZXNbaV0uYnVsZ2UpIHtcclxuICAgICAgICAgICAgICAgIGJ1bGdlID0gZW50aXR5LnZlcnRpY2VzW2ldLmJ1bGdlO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGVuZFBvaW50ID0gaSArIDEgPCBlbnRpdHkudmVydGljZXMubGVuZ3RoID8gZW50aXR5LnZlcnRpY2VzW2kgKyAxXSA6IGdlb21ldHJ5LnZlcnRpY2VzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1bGdlR2VvbWV0cnkgPSBuZXcgVEhSRUV4LkJ1bGdlR2VvbWV0cnkoc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoLmFwcGx5KGdlb21ldHJ5LnZlcnRpY2VzLCBidWxnZUdlb21ldHJ5LnZlcnRpY2VzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjModmVydGV4LngsIHZlcnRleC55LCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVudGl0eS5zaGFwZSkgZ2VvbWV0cnkudmVydGljZXMucHVzaChnZW9tZXRyeS52ZXJ0aWNlc1swXSk7XHJcblxyXG5cclxuICAgICAgICAvLyBzZXQgbWF0ZXJpYWxcclxuICAgICAgICBpZihlbnRpdHkubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgbGluZVR5cGUgPSBkYXRhLnRhYmxlcy5saW5lVHlwZS5saW5lVHlwZXNbZW50aXR5LmxpbmVUeXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxpbmVUeXBlICYmIGxpbmVUeXBlLnBhdHRlcm4gJiYgbGluZVR5cGUucGF0dGVybi5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKHsgY29sb3I6IGNvbG9yLCBnYXBTaXplOiA0LCBkYXNoU2l6ZTogNH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgbGluZXdpZHRoOiAxLCBjb2xvcjogY29sb3IgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cclxuICAgICAgICAvLyAgICAgICAgICAgLy8gVWdseSBoYWNrIHRvIGFkZCBkaWZmdXNlIHRvIHRoaXMuIE1heWJlIGNvcHkgdGhlIHVuaWZvcm1zIG9iamVjdCBzbyB3ZVxyXG4gICAgICAgIC8vICAgICAgICAgICAvLyBkb24ndCBhZGQgZGlmZnVzZSB0byBhIG1hdGVyaWFsLlxyXG4gICAgICAgIC8vICAgICAgICAgICBsaW5lVHlwZS5tYXRlcmlhbC51bmlmb3Jtcy5kaWZmdXNlID0geyB0eXBlOiAnYycsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoY29sb3IpIH07XHJcblxyXG4gICAgICAgIC8vIFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xyXG4gICAgICAgIC8vIFx0XHR1bmlmb3JtczogbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMsXHJcbiAgICAgICAgLy8gXHRcdHZlcnRleFNoYWRlcjogbGluZVR5cGUubWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG4gICAgICAgIC8vIFx0XHRmcmFnbWVudFNoYWRlcjogbGluZVR5cGUubWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAvLyBcdH0pO1xyXG4gICAgICAgIC8vIH1lbHNlIHtcclxuICAgICAgICAvLyBcdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgbGluZXdpZHRoOiAxLCBjb2xvcjogY29sb3IgfSk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZHJhd0FyYyhlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgc3RhcnRBbmdsZSwgZW5kQW5nbGU7XHJcbiAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJykge1xyXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50aXR5LnN0YXJ0QW5nbGUgfHwgMDtcclxuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudGl0eS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVudGl0eS5lbmRBbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5BcmNDdXJ2ZShcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgZW50aXR5LnJhZGl1cyxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgZW5kQW5nbGUpO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCAzMiApO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcclxuXHJcbiAgICAgICAgdmFyIGFyYyA9IG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnggPSBlbnRpdHkuY2VudGVyLng7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnkgPSBlbnRpdHkuY2VudGVyLnk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnogPSBlbnRpdHkuY2VudGVyLno7XHJcblxyXG4gICAgICAgIHJldHVybiBhcmM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCwgbWVzaCwgdmVydHMsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgIHZlcnRzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzBdLngsIGVudGl0eS5wb2ludHNbMF0ueSwgZW50aXR5LnBvaW50c1swXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzFdLngsIGVudGl0eS5wb2ludHNbMV0ueSwgZW50aXR5LnBvaW50c1sxXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzJdLngsIGVudGl0eS5wb2ludHNbMl0ueSwgZW50aXR5LnBvaW50c1syXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzNdLngsIGVudGl0eS5wb2ludHNbM10ueSwgZW50aXR5LnBvaW50c1szXS56KSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBkaXJlY3Rpb24gdGhlIHBvaW50cyBhcmUgZmFjaW5nIChjbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2UpXHJcbiAgICAgICAgdmFyIHZlY3RvcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2ZWN0b3IxLnN1YlZlY3RvcnModmVydHNbMV0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IyLnN1YlZlY3RvcnModmVydHNbMl0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IxLmNyb3NzKHZlY3RvcjIpO1xyXG5cclxuICAgICAgICAvLyBJZiB6IDwgMCB0aGVuIHdlIG11c3QgZHJhdyB0aGVzZSBpbiByZXZlcnNlIG9yZGVyXHJcbiAgICAgICAgaWYodmVjdG9yMS56IDwgMCkge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygyLCAxLCAwKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDIsIDMsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygwLCAxLCAyKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDEsIDMsIDIpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3VGV4dChlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnksIG1hdGVyaWFsLCB0ZXh0O1xyXG5cclxuICAgICAgICBpZighZm9udClcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignVGV4dCBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgYSBUaHJlZS5qcyBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIhIExvYWQgYSBmb250IG9mIHlvdXIgY2hvaWNlIGFuZCBwYXNzIHRoaXMgaW50byB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2FtcGxlIGZvciB0aGlzIHJlcG9zaXRvcnkgb3IgVGhyZWUuanMgZXhhbXBsZXMgYXQgaHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzLz9xPXRleHQjd2ViZ2xfZ2VvbWV0cnlfdGV4dCBmb3IgbW9yZSBkZXRhaWxzLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShlbnRpdHkudGV4dCwgeyBmb250OiBmb250LCBoZWlnaHQ6IDAsIHNpemU6IGVudGl0eS50ZXh0SGVpZ2h0IHx8IDEyIH0pO1xyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICB0ZXh0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkuc3RhcnRQb2ludC54O1xyXG4gICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5zdGFydFBvaW50Lnk7XHJcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gZW50aXR5LnN0YXJ0UG9pbnQuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BvaW50KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSwgbWF0ZXJpYWwsIHBvaW50O1xyXG5cclxuICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb3NpdGlvbi54LCBlbnRpdHkucG9zaXRpb24ueSwgZW50aXR5LnBvc2l0aW9uLnopKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY291bGQgYmUgbW9yZSBlZmZpY2llbnQuIFBvaW50Q2xvdWQgcGVyIGxheWVyP1xyXG5cclxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gMTtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtUG9pbnRzKjMgKTtcclxuICAgICAgICBjb2xvcnNbMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIGNvbG9yc1sxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgY29sb3JzWzJdID0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzID0gY29sb3JzO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBzaXplOiAwLjA1LCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcbiAgICAgICAgcG9pbnQgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgc2NlbmUuYWRkKHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmxvY2soZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5Lm5hbWVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghYmxvY2suZW50aXRpZXMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGVudGl0eS54U2NhbGUpIGdyb3VwLnNjYWxlLnggPSBlbnRpdHkueFNjYWxlO1xyXG4gICAgICAgIGlmKGVudGl0eS55U2NhbGUpIGdyb3VwLnNjYWxlLnkgPSBlbnRpdHkueVNjYWxlO1xyXG5cclxuICAgICAgICBpZihlbnRpdHkucm90YXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucm90YXRpb24ueiA9IGVudGl0eS5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbnRpdHkucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGdyb3VwLnBvc2l0aW9uLnogPSBlbnRpdHkucG9zaXRpb24uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2NrLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZEVudGl0eSA9IGRyYXdFbnRpdHkoYmxvY2suZW50aXRpZXNbaV0sIGRhdGEsIGdyb3VwKTtcclxuICAgICAgICAgICAgaWYoY2hpbGRFbnRpdHkpIGdyb3VwLmFkZChjaGlsZEVudGl0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gMHgwMDAwMDA7IC8vZGVmYXVsdFxyXG4gICAgICAgIGlmKGVudGl0eS5jb2xvcikgY29sb3IgPSBlbnRpdHkuY29sb3I7XHJcbiAgICAgICAgZWxzZSBpZihkYXRhLnRhYmxlcyAmJiBkYXRhLnRhYmxlcy5sYXllciAmJiBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXSlcclxuICAgICAgICAgICAgY29sb3IgPSBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXS5jb2xvcjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYoY29sb3IgPT0gbnVsbCB8fCBjb2xvciA9PT0gMHhmZmZmZmYpIHtcclxuICAgICAgICAgICAgY29sb3IgPSAweDAwMDAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKSB7XHJcbiAgICAgICAgdmFyIGx0eXBlLCB0eXBlO1xyXG4gICAgICAgIGlmKCFkYXRhLnRhYmxlcyB8fCAhZGF0YS50YWJsZXMubGluZVR5cGUpIHJldHVybjtcclxuICAgICAgICB2YXIgbHR5cGVzID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzO1xyXG5cclxuICAgICAgICBmb3IodHlwZSBpbiBsdHlwZXMpIHtcclxuICAgICAgICAgICAgbHR5cGUgPSBsdHlwZXNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmKCFsdHlwZS5wYXR0ZXJuKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbHR5cGUubWF0ZXJpYWwgPSBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKGx0eXBlLnBhdHRlcm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKHBhdHRlcm4pIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgZGFzaGVkTGluZVNoYWRlciA9IHt9LFxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDAuMDtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLmFicyhwYXR0ZXJuW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyAnY29tbW9uJyBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgJ2ZvZycgXSxcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzogeyB0eXBlOiAnZnYxJywgdmFsdWU6IHBhdHRlcm4gfSxcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuTGVuZ3RoJzogeyB0eXBlOiAnZicsIHZhbHVlOiB0b3RhbExlbmd0aCB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudmVydGV4U2hhZGVyID0gW1xyXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdLFxyXG5cclxuICAgICAgICAgICAgJ3ZMaW5lRGlzdGFuY2UgPSBsaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7JyxcclxuXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBbXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBwYXR0ZXJuWycgKyBwYXR0ZXJuLmxlbmd0aCArICddOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHBhdHRlcm5MZW5ndGg7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgICdmbG9hdCBwb3MgPSBtb2QodkxpbmVEaXN0YW5jZSwgcGF0dGVybkxlbmd0aCk7JyxcclxuXHJcbiAgICAgICAgICAgICdmb3IgKCBpbnQgaSA9IDA7IGkgPCAnICsgcGF0dGVybi5sZW5ndGggKyAnOyBpKysgKSB7JyxcclxuICAgICAgICAgICAgJ3BvcyA9IHBvcyAtIGFicyhwYXR0ZXJuW2ldKTsnLFxyXG4gICAgICAgICAgICAnaWYoIHBvcyA8IDAuMCApIHsnLFxyXG4gICAgICAgICAgICAnaWYoIHBhdHRlcm5baV0gPiAwLjAgKSB7JyxcclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgb3BhY2l0eSApOycsXHJcbiAgICAgICAgICAgICdicmVhazsnLFxyXG4gICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICdkaXNjYXJkOycsXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnZm9nX2ZyYWdtZW50JyBdLFxyXG5cclxuICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhc2hlZExpbmVTaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEV4dGVudHMoc2NlbmUpIHsgXHJcbiAgICAgICAgZm9yKHZhciBjaGlsZCBvZiBzY2VuZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcclxuICAgICAgICAgICAgaWYoY2hpbGQucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi54LCBtaW5YKTtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi55LCBtaW5ZKTtcclxuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi54LCBtYXhYKTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi55LCBtYXhZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgbWluOiB7IHg6IG1pblgsIHk6IG1pblkgfSwgbWF4OiB7IHg6IG1heFgsIHk6IG1heFkgfX07XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8gU2hvdy9IaWRlIGhlbHBlcnMgZnJvbSBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvZWZmZWN0cy9oaWRlLW9yLXNob3ctYW4tZWxlbWVudC00Mi9cclxuLy8gZ2V0IHRoZSBkZWZhdWx0IGRpc3BsYXkgc3R5bGUgb2YgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSh0YWcpIHtcclxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgMCk7XHJcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xyXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMCk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuXHJcbiAgICB2YXIgZG9jID0gKGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50O1xyXG5cclxuICAgIC8vIElFIHN1cHBvcnRcclxuICAgIGRvYy53cml0ZSgpO1xyXG4gICAgZG9jLmNsb3NlKCk7XHJcblxyXG4gICAgdmFyIHRlc3RFbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRlc3RFbCk7XHJcbiAgICB2YXIgZGlzcGxheSA9ICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUodGVzdEVsLCBudWxsKSA6IHRlc3RFbC5jdXJyZW50U3R5bGUpLmRpc3BsYXlcclxuICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxufVxyXG5cclxuLy8gYWN0dWFsIHNob3cvaGlkZSBmdW5jdGlvbiB1c2VkIGJ5IHNob3coKSBhbmQgaGlkZSgpIGJlbG93XHJcbmZ1bmN0aW9uIHNob3dIaWRlKGVsLCBzaG93KSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2xkZGlzcGxheScpLFxyXG4gICAgZGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXksXHJcbiAgICBjb21wdXRlZERpc3BsYXkgPSAod2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKSA6IGVsLmN1cnJlbnRTdHlsZSkuZGlzcGxheTtcclxuXHJcbiAgICBpZiAoc2hvdykge1xyXG4gICAgICAgIGlmICghdmFsdWUgJiYgZGlzcGxheSA9PT0gJ25vbmUnKSBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIChjb21wdXRlZERpc3BsYXkgPT09ICdub25lJykpIHZhbHVlID0gdmFsdWUgfHwgZGVmYXVsdERpc3BsYXkoZWwubm9kZU5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZGlzcGxheSAmJiBkaXNwbGF5ICE9PSAnbm9uZScgfHwgIShjb21wdXRlZERpc3BsYXkgPT0gJ25vbmUnKSlcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW9sZGRpc3BsYXknLCAoY29tcHV0ZWREaXNwbGF5ID09ICdub25lJykgPyBkaXNwbGF5IDogY29tcHV0ZWREaXNwbGF5KTtcclxuICAgIH1cclxuICAgIGlmICghc2hvdyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJycpXHJcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZSB8fCAnJyA6ICdub25lJztcclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBzaG93KGVsKSB7IHNob3dIaWRlKGVsLCB0cnVlKTsgfVxyXG5mdW5jdGlvbiBoaWRlKGVsKSB7IHNob3dIaWRlKGVsKTsgfVxyXG5cclxuXHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}])});